* Guard1 Pattern

#+BEGIN_SRC lisp
(guard1 symbol test-form {generator-form subpattern}*)
#+END_SRC

+ Unlike original =guard= pattern, guard1 patterns do not allow subpatterns
  in =symbol=. 1 guard1 pattern corresponds to exactly 1 type checking.
  Instead, =symbol= may contain additional lexical
  information. For details see the next section.
+ Level-1 patterns should be canonical. That is, there should be no
  forward-referenced symbols.

Thus, compilation of =guard1= is equivalent to just building a
form consisting of =if= and =let= binding. =match1= assumes the
matching tree is already valid and optimized.

Example:

#+BEGIN_SRC lisp
(match1 '(1 2)
  ((guard1 temp (consp temp)
           (car temp) (guard1 a t)
           (cadr temp) (guard1 b t))
   (vector a b)))

;; --> #(1 2)
#+END_SRC

Note that, since even variable patterns are missing in Level 1,
one should use =(guard1 a t)= to bind the value generated by =(car
temp)=. It produces a code like below.

#+BEGIN_SRC lisp
(LET ((#:WHAT1862 '(1 2)))
  (BLOCK NIL
    (LET ((TEMP #:WHAT1862))
      (WHEN (CONSP TEMP)
        (LET ((A (CAR TEMP)))
          (WHEN T
            (LET ((B (CADR TEMP)))
              (WHEN T (RETURN (LOCALLY (VECTOR A B)))))))))))
#+END_SRC

** Extended Syntax of Guard1

As noted earlier, =guard1= may contain additional lexical declaration information within =symbol=. While the normal syntax of guard1 is as follows:

#+BEGIN_SRC lisp
(guard1 symbol test-form {generator-form subpattern}*)
#+END_SRC

the extended guard1 syntax is:

#+BEGIN_SRC lisp
(guard1 (sym &key
           (type t)
           place
           (ignorable (if (symbol-package sym) nil t))
         &allow-other-keys)
        test-form {generator-form subpattern}*)
#+END_SRC

- type :: a type specifier. It is added to the declaration after =let=.
- place :: if this key is non-nil, then the symbol is bound with
           symbol-macrolet and the accessor becomes setf-able.
- ignorable :: If non-nil, =symbol= is declared to be =ignorable=, and is
               not accounted for or1 pattern consistency check. Default
               value is =T= when =symbol= is a non-interned symbol, and
               =NIL= otherwise.

Note that =type= does not affect the optimization nor the test form. The declaration is added only to the conditional branch where the test form is evaluated to be true.

* Or1 Pattern

: (or1 subpattens*)

If the sets of variables under =or1= subpatterns are not the same, missing variables are assigned NIL.

#+BEGIN_SRC lisp
(defun test (x)
   (match x
     ;; using level2 cons/vector pattern for convenience
     ((or1 (cons a b)
           (vector a c)) (values a b c))))

(test '(1 . 2)) ;; --> 1, 2, nil
(test #(1 2)) ;; --> 1, nil, 2
#+END_SRC

This behavior can be changed by setting =*or-pattern-allow-unshared-variables*= to =NIL=. When two subpatterns do not share the same set of patterns, it can signal an assertion error of type =or1-pattern-inconsistency=, with =(repair-pattern subpattern)= restart. You may fix the subpattern and call this handler with a new pattern.
