Level 2 includes all the patterns in =:optima= and =:optima.extra= package,
plus several additional patterns.

* Specialized Vector Patterns

#+BEGIN_SRC lisp
<vector-pattern> : vector      | simple-vector
                   bit-vector  | simple-bit-vector
                   string      | simple-string
                   base-string | simple-base-string | sequence 
(<vector-pattern> &rest subpatterns)
#+END_SRC

The family of vector-patterns also have /soft-match/ variants like
=vector*=, which matches against the vectors with insufficient number of
elements, binding the remaining unmatched variables with NIL.

* Bind Pattern

: (<> pattern value &optional var)

The current matching value is bound to =var=.
The result of evaluating =value= using =var= is then matched against =pattern=.
=var= is optional when =value= does not need the current matching value.

* Access Pattern

Just want to access an element? It's time to use =access= pattern: 

#+BEGIN_SRC lisp
(access #'accessor subpattern) ; or
(access 'accessor subpattern)
#+END_SRC

These expand into 

#+BEGIN_SRC lisp
(with-gensyms (it)
  `(guard1 ,it t (,accessor ,it) ,subpattern))
#+END_SRC


* Level 2 Matcher variants

As in optima, there are several variants in the matcher construct:

: [ec]?match value &body clauses
: [ec]?match* (&rest values) &body multi-match-clauses
: multiple-value-[ec]?match values-form &body multi-match-clauses

Optima has =match*= variants internally, but it is not exporting the
symbols.  It takes a list of forms as the first argument and matches the
values against each multi-pattern. For any multi-patterns, the values are
checked in left-to-right.

*Example*:

#+BEGIN_SRC lisp
(match* ((list 2) (list 3) (list 5))
  (((list x) (list y) (list (guard z (= z (+ x y))))) z)) ;; --> 5
#+END_SRC

=match+=, in contrast, is NOT a clause intended for the standard use of
Trivia. It is rather for the programmer who is writing an optimizer.

#+BEGIN_SRC lisp
macro match+ ((&rest whats) (&rest types) &body clauses)
#+END_SRC

types, not evaluated, is a list of type specifiers. Optimizer can benefit
from this type information by eliminating redundant branches.
