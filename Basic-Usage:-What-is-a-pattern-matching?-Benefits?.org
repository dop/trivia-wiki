Pattern Matching is basically a combination of nested =COND= and
destructuring, such as =destructuring-bind= , =with-slot= and =with-accessors=. 
There are already [[http://ja.reddit.com/r/lisp/comments/2xl23i/explain_pattern_matching_eli5_style/][ample of]] [[http://enthusiasm.cozy.org/archives/2013/07/optima][introduction to]] [[http://www.paulgraham.com/onlisptext.html][pattern]] [[https://github.com/tpapp/let-plus][matching]], but I'd like to give another try with a concrete example.

Consider the following:

#  that tries
# to check if the variable =X= is a list beginning with =:a=, and if that
# fails then check if the variable is an object of class =C= with slot =:a=

#+BEGIN_SRC lisp
(defvar x '(:a 2 10))

(cond
  ((and (typep x 'foo)
        (eq :a (slot-value x 'baz)))
   (let ((b (slot-value x 'bar)))
     ...body1...))
  ((and (and (listp x)
             (= 3 (length x)))
        (eq (first x) :a))
   (let ((b (second x))) ;; b is bound to 10
     ...body2...)))
#+END_SRC

With pattern matching, you can write the same program shorter, as follows:

#+BEGIN_SRC lisp
(match x
  ((foo (bar b) (baz :a))
   ...body1...)
  ((list* :a b _)
   ...body2...))
#+END_SRC

Let's break it down into details.

#+BEGIN_SRC diff
+ (match x
#+END_SRC

Now above line starts a pattern matching construct. =match= is a macro and
the first argument is a form that is evaluated and matched against. 

The next line specifies that the first pattern checks if the given object
is of type =foo=.

#+BEGIN_SRC diff
(match x
+  ((foo
#+END_SRC

This kind of pattern is called a
=class= pattern, and matches against any objects under standard-object and structure-object.

The first subform of that =class= pattern, or a /subpattern/, is =(bar b)= and it
specifies the slot. It binds the value of the slot to a variable =b= with
=let=, just like =with-slots=. Any non-self-evaluating symbols such as =b= are
called =variable= patterns and creates a =let= binding in the macroexpanded code.

#+BEGIN_SRC diff
(match x
-  ((foo
+  ((foo (bar b)
#+END_SRC

The second subpattern specifies another slot =baz=. Here, the subpattern is
=:a= which satisfies =constantp=. It is called a /constant pattern/ and the elements are compared with =eq,eql,equal,equalp= depending on the constant.

#+BEGIN_SRC diff
(match x
-  ((foo (bar b)
+  ((foo (bar b) (baz :a))
+   ...body1...)
#+END_SRC

If all of these query matches the input =x=, then =body1= is
executed under the lexical environment where =b= is bound to the contents
of the slot =bar= of =x=. This pair of a pattern and a body is called a clause.

Now, remember that the value of =x= was a list =(:a 2 10)= . This is not of
class =foo= and hence it does not satisfy the test.  In this case, there is
no need to check the constant pattern =(baz :a)= --- =(eq (slot-value x 'baz) :a)=. Pattern matcher
skips these unsatisfiable tests and start checking the second
pattern clause immediately.

#+BEGIN_SRC diff
(match x
  ((foo (bar b) (baz :a))
   ...body1...)
+  ((list :a b _)
+   ...body2...))
#+END_SRC

The next clause is a =list= pattern, and it checks if =x= is a list of length 3. Its first subpattern
is a constant pattern. The second subpattern is a variable pattern. And the
last subpattern is a /wildcard/ pattern, which states it /doesn't care/. It
*does* check the length test, but it runs no check against
the corresponding element of the list, nor does it bind any variables with =let=.

Since this pattern matches against =(:a 2 10)=, execution
goes to the body of the clause =body2=.  The body is treated as an implicit
progn and the last value of the body is returned as the value of
=match=. If none of the pattern matches, it returns nil.

Patterns can be nested. For example, the following code returns =4=. This property allows us to access and test the elements of a deeply nested structure in a simple language, without writing the accessing code explicitly.

#+BEGIN_SRC lisp
(match '(:a (3 4) 5)
  ((list :a (list _ c) _)
   c))
#+END_SRC

Go to the [[./Basic-Usage:-Patterns][next page]] for a full catalogue of other patterns.
